(function(){"use strict";const b=(t,s)=>{const n=new Map([[t,0]]),e=[t];let o=0,c=0;for(;c<e.length;){const i=e[c++],l=n.get(i);l>o&&(o=l);const d=s.get(i)||[];for(const r of d)n.has(r)||(n.set(r,l+1),e.push(r))}return{distances:n,maxDistance:o}},A=(t,s)=>{const n=[],e=new Set;for(const o of t.nodes)if(!e.has(o.id)){const c=[],i=[o.id];e.add(o.id);let l=0;for(;l<i.length;){const d=i[l++];c.push(d);for(const r of s.get(d)||[])e.has(r)||(e.add(r),i.push(r))}n.push(c)}return n},E=(t,s)=>t<2?0:2*s/(t*(t-1)),j=(t,s)=>{let n=0;const e=t.length;let o=0;if(e<2)return 0;for(const c of t){const{distances:i}=b(c,s);for(const[l,d]of i.entries())c!==l&&(n+=d,o++)}return o>0?n/o:0},P=(t,s)=>{const n=new Set,e=new Set,o=new Map,c=new Map,i=new Map;let l=0;const d=r=>{e.add(r),o.set(r,l),c.set(r,l),l++;let h=0;const a=s.get(r)||[];for(const u of a)u!==i.get(r)&&(e.has(u)?c.set(r,Math.min(c.get(r),o.get(u))):(h++,i.set(u,r),d(u),c.set(r,Math.min(c.get(r),c.get(u))),i.get(r)===null&&h>1&&n.add(r),i.get(r)!==null&&c.get(u)>=o.get(r)&&n.add(r)))};for(const r of t)e.has(r)||(i.set(r,null),d(r));return Array.from(n)},S=(t,s)=>{const n=new Map;for(const e of t)n.set(e,0);for(const e of t){const o=[],c=new Map,i=new Map,l=new Map;for(const a of t)c.set(a,[]),i.set(a,0),l.set(a,-1);i.set(e,1),l.set(e,0);const d=[e];let r=0;for(;r<d.length;){const a=d[r++];o.push(a);const u=s.get(a)||[];for(const w of u)l.get(w)<0&&(d.push(w),l.set(w,l.get(a)+1)),l.get(w)===l.get(a)+1&&(i.set(w,i.get(w)+i.get(a)),c.get(w).push(a))}const h=new Map;for(const a of t)h.set(a,0);for(;o.length>0;){const a=o.pop();for(const u of c.get(a)){const w=i.get(u)/i.get(a)*(1+h.get(a));h.set(u,h.get(u)+w)}a!==e&&n.set(a,n.get(a)+h.get(a))}}return t.map(e=>({node:{id:e},value:n.get(e)/2})).sort((e,o)=>o.value-e.value).slice(0,5)},B=(t,s)=>t.nodes.map(n=>({node:n,value:(s.get(n.id)||[]).length})).sort((n,e)=>e.value-n.value).slice(0,5),x=t=>{const s=new Map;for(const n of t.values()){const e=n.length;s.set(e,(s.get(e)||0)+1)}return Array.from(s.entries()).map(([n,e])=>({degree:n,count:e})).sort((n,e)=>n.degree-e.degree)},C=t=>{const s=new Map,n=e=>{if(s.has(e))return s.get(e);const o=new Set,c=t.get(e)||[];for(const i of c)o.add(i),n(i).forEach(d=>o.add(d));return s.set(e,o),o};return n},z=t=>{const s=new Map;t.links.forEach(e=>{if(e.type==="parent-child"){const o=typeof e.source=="object"?e.source.id:e.source,c=typeof e.target=="object"?e.target.id:e.target;s.has(o)||s.set(o,[]),s.get(o).push(c)}});const n=C(s);return t.nodes.map(e=>({node:e,value:n(e.id).size})).sort((e,o)=>o.value-e.value).slice(0,5)},F=t=>{const s=new Map;t.links.forEach(e=>{if(e.type==="parent-child"){const o=typeof e.source=="object"?e.source.id:e.source,c=typeof e.target=="object"?e.target.id:e.target;s.has(c)||s.set(c,[]),s.get(c).push(o)}});const n=C(s);return t.nodes.map(e=>({node:e,value:n(e.id).size})).sort((e,o)=>o.value-e.value).slice(0,5)},G=t=>{const s=t.nodes.length,n=t.links.length,e=t.links.some(f=>f.type==="parent-child"||f.type==="marriage"),o=new Map(t.nodes.map(f=>[f.id,f])),c=new Map;t.nodes.forEach(f=>c.set(f.id,[])),t.links.forEach(({source:f,target:p})=>{var g,m;const M=typeof f=="object"&&f!==null?f.id:f,v=typeof p=="object"&&p!==null?p.id:p;(g=c.get(M))==null||g.push(v),(m=c.get(v))==null||m.push(M)});const i=A(t,c),l=i.length,d=i.reduce((f,p)=>p.length>f.length?p:f,[]),r=d.length;let h="N/A",a="N/A",u=[],w=[];if(r>1){let f=0;const p=new Map;d.forEach(g=>{p.set(g,c.get(g)||[])});for(const g of d){const{maxDistance:m}=b(g,p);m>f&&(f=m)}h=f,a=parseFloat(j(d,p).toFixed(2)),u=P(d,p).slice(0,5).map(g=>o.get(g)).filter(Boolean),w=S(d,p).map(g=>({...g,node:o.get(g.node.id)||g.node})).filter(g=>g.node)}else r<=1&&s>0&&(h=0,a=0);const q=parseFloat(E(s,n).toFixed(4)),y={nodeCount:s,edgeCount:n,componentCount:l,isConnected:l===1,largestComponentSize:r,diameter:h,graphDensity:q,averageShortestPath:a,articulationPoints:u};return y.centralityByConnections=B(t,c),y.degreeDistribution=x(c),y.betweennessCentrality=w,e&&(y.centralityByDescendants=z(t),y.centralityByAncestors=F(t)),y};self.onmessage=t=>{try{const s=t.data;if(!s)throw new Error("No graph data received by worker.");const n=G(s);self.postMessage({type:"success",result:n})}catch(s){const n=s instanceof Error?s.message:"An unknown error occurred in the worker.";self.postMessage({type:"error",error:n})}}})();
